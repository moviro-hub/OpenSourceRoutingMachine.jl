var documenterSearchIndex = {"docs":
[{"location":"api/core/#Core-API","page":"Core API","title":"Core API","text":"Core types, configuration, and utilities.","category":"section"},{"location":"api/core/#Types","page":"Core API","title":"Types","text":"","category":"section"},{"location":"api/core/#Configuration-Functions","page":"Core API","title":"Configuration Functions","text":"","category":"section"},{"location":"api/core/#Version-and-Compatibility","page":"Core API","title":"Version and Compatibility","text":"","category":"section"},{"location":"api/core/#OpenSourceRoutingMachine.LatLon","page":"Core API","title":"OpenSourceRoutingMachine.LatLon","text":"LatLon\n\nA named tuple representing a latitude and longitude coordinate pair.\n\n\n\n\n\n","category":"type"},{"location":"api/core/#OpenSourceRoutingMachine.OSRM","page":"Core API","title":"OpenSourceRoutingMachine.OSRM","text":"OSRM(base_path::String)\n\nHigh-level handle for querying an OSRM dataset located at base_path.\n\n\n\n\n\n","category":"type"},{"location":"api/core/#OpenSourceRoutingMachine.OSRMConfig","page":"Core API","title":"OpenSourceRoutingMachine.OSRMConfig","text":"OSRMConfig(base_path::String)\n\nLow-level configuration handle for OSRM; most callers will use OSRM(base_path) instead of constructing this directly.\n\n\n\n\n\n","category":"type"},{"location":"api/core/#OpenSourceRoutingMachine.set_algorithm!-Tuple{OSRMConfig, Any}","page":"Core API","title":"OpenSourceRoutingMachine.set_algorithm!","text":"set_algorithm!(config::OSRMConfig, algorithm)\n\nForce a specific routing algorithm for the given configuration instead of letting it be inferred from dataset files on disk.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_dataset_name!-Tuple{OSRMConfig, Union{Nothing, AbstractString}}","page":"Core API","title":"OpenSourceRoutingMachine.set_dataset_name!","text":"set_dataset_name!(config::OSRMConfig, dataset_name)\n\nSelect which named dataset OSRM should attach to when running in shared-memory mode (or clear it by passing nothing).\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_default_radius!-Tuple{OSRMConfig, Real}","page":"Core API","title":"OpenSourceRoutingMachine.set_default_radius!","text":"set_default_radius!(config::OSRMConfig, radius)\n\nSet the default snapping radius used when no per-coordinate radius is provided.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_max_alternatives!-Tuple{OSRMConfig, Integer}","page":"Core API","title":"OpenSourceRoutingMachine.set_max_alternatives!","text":"set_max_alternatives!(config::OSRMConfig, max_alternatives)\n\nConfigure the global upper bound on how many route alternatives OSRM may return.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_max_locations_distance_table!-Tuple{OSRMConfig, Integer}","page":"Core API","title":"OpenSourceRoutingMachine.set_max_locations_distance_table!","text":"set_max_locations_distance_table!(config::OSRMConfig, max_locations)\n\nConfigure the maximum number of locations accepted for Table (matrix) queries.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_max_locations_map_matching!-Tuple{OSRMConfig, Integer}","page":"Core API","title":"OpenSourceRoutingMachine.set_max_locations_map_matching!","text":"set_max_locations_map_matching!(config::OSRMConfig, max_locations)\n\nConfigure how many coordinates OSRM will accept for Map Matching requests.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_max_locations_trip!-Tuple{OSRMConfig, Integer}","page":"Core API","title":"OpenSourceRoutingMachine.set_max_locations_trip!","text":"set_max_locations_trip!(config::OSRMConfig, max_locations)\n\nConfigure the maximum number of locations OSRM will accept for Trip queries.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_max_radius_map_matching!-Tuple{OSRMConfig, Real}","page":"Core API","title":"OpenSourceRoutingMachine.set_max_radius_map_matching!","text":"set_max_radius_map_matching!(config::OSRMConfig, radius)\n\nSet the maximum search radius OSRM will use when snapping points for Map Matching queries.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_max_results_nearest!-Tuple{OSRMConfig, Integer}","page":"Core API","title":"OpenSourceRoutingMachine.set_max_results_nearest!","text":"set_max_results_nearest!(config::OSRMConfig, max_results)\n\nLimit how many nearest candidates OSRM should return for Nearest queries.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_use_mmap!-Tuple{OSRMConfig, Bool}","page":"Core API","title":"OpenSourceRoutingMachine.set_use_mmap!","text":"set_use_mmap!(config::OSRMConfig, use_mmap)\n\nToggle whether OSRM should memory-map datasets instead of loading them fully into RAM.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.set_use_shared_memory!-Tuple{OSRMConfig, Bool}","page":"Core API","title":"OpenSourceRoutingMachine.set_use_shared_memory!","text":"set_use_shared_memory!(config::OSRMConfig, use_shared_memory)\n\nControl whether OSRM should attach to a shared-memory region populated by osrm-datastore for dataset access.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.get_version-Tuple{}","page":"Core API","title":"OpenSourceRoutingMachine.get_version","text":"get_version() -> UInt32\n\nReturn the libosrmc/OSRM ABI version that this wrapper is linked against.\n\n\n\n\n\n","category":"method"},{"location":"api/core/#OpenSourceRoutingMachine.is_abi_compatible-Tuple{}","page":"Core API","title":"OpenSourceRoutingMachine.is_abi_compatible","text":"is_abi_compatible() -> Bool\n\nReport whether the loaded libosrmc library matches the version this package was built against, so callers can fail fast on mismatched binaries.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#Trip-API","page":"Trip API","title":"Trip API","text":"Solve traveling salesman problems.","category":"section"},{"location":"api/trip/#Functions","page":"Trip API","title":"Functions","text":"","category":"section"},{"location":"api/trip/#Types","page":"Trip API","title":"Types","text":"","category":"section"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips._trip_response_destruct-Tuple{Ptr{Nothing}}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips._trip_response_destruct","text":"TripResponse\n\nOwns the raw libosrmc trip response pointer and ensures it is freed when the Julia object goes out of scope.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.add_alternatives!-Tuple{TripParams, Bool}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.add_alternatives!","text":"add_alternatives!(params::TripParams, on)\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.add_steps!-Tuple{TripParams, Bool}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.add_steps!","text":"add_steps!(params::TripParams, on)\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.set_annotations!-Tuple{TripParams, AbstractString}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.set_annotations!","text":"set_annotations!(params::TripParams, annotations)\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.set_continue_straight!-Tuple{TripParams, Bool}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.set_continue_straight!","text":"set_continue_straight!(params::TripParams, on)\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.set_geometries!-Tuple{TripParams, AbstractString}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.set_geometries!","text":"set_geometries!(params::TripParams, geometries)\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.set_number_of_alternatives!-Tuple{TripParams, Integer}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.set_number_of_alternatives!","text":"set_number_of_alternatives!(params::TripParams, count)\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.set_overview!-Tuple{TripParams, AbstractString}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.set_overview!","text":"set_overview!(params::TripParams, overview)\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.trip-Tuple{OSRM, TripParams}","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.trip","text":"trip(osrm::OSRM, params::TripParams) -> TripResponse\n\nQuery the Trip service and return a response object.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.add_destination!-Tuple{TripParams, AbstractString}","page":"Trip API","title":"OpenSourceRoutingMachine.add_destination!","text":"add_destination!(params::TripParams, destination)\n\nSame as add_source! but for the tour endpoint so depot returns and open tours can be modeled explicitly.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.add_roundtrip!-Tuple{TripParams, Bool}","page":"Trip API","title":"OpenSourceRoutingMachine.add_roundtrip!","text":"add_roundtrip!(params::TripParams, on)\n\nControls whether OSRM should force start and end to coincide, critical when optimizing delivery tours vs. point-to-point trips.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.add_source!-Tuple{TripParams, AbstractString}","page":"Trip API","title":"OpenSourceRoutingMachine.add_source!","text":"add_source!(params::TripParams, source)\n\nFixes the trip's start behavior (first/last/any), ensuring OSRM respects business constraints like fixed depots.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.add_waypoint!-Tuple{TripParams, Integer}","page":"Trip API","title":"OpenSourceRoutingMachine.add_waypoint!","text":"add_waypoint!(params::TripParams, index)\n\nLocks a coordinate index as a fixed visit, which is necessary when mixing mandatory stops with OSRM's optimized order.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.as_json-Tuple{TripResponse}","page":"Trip API","title":"OpenSourceRoutingMachine.as_json","text":"as_json(response::TripResponse) -> String\n\nRetrieve the entire response as JSON string.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.clear_waypoints!-Tuple{TripParams}","page":"Trip API","title":"OpenSourceRoutingMachine.clear_waypoints!","text":"clear_waypoints!(params::TripParams)\n\nRemoves any previously selected fixed stops so you can iterate on waypoint ordering without reallocating params.\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.get_distance-Tuple{TripResponse}","page":"Trip API","title":"OpenSourceRoutingMachine.get_distance","text":"get_distance(response::TripResponse) -> Float64\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.get_duration-Tuple{TripResponse}","page":"Trip API","title":"OpenSourceRoutingMachine.get_duration","text":"get_duration(response::TripResponse) -> Float64\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.get_waypoint_coordinate-Tuple{TripResponse, Integer}","page":"Trip API","title":"OpenSourceRoutingMachine.get_waypoint_coordinate","text":"get_waypoint_coordinate(response::TripResponse, index) -> LatLon\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.get_waypoint_count-Tuple{TripResponse}","page":"Trip API","title":"OpenSourceRoutingMachine.get_waypoint_count","text":"get_waypoint_count(response::TripResponse) -> Int\n\n\n\n\n\n","category":"method"},{"location":"api/trip/#OpenSourceRoutingMachine.Trips.TripParams","page":"Trip API","title":"OpenSourceRoutingMachine.Trips.TripParams","text":"TripParams()\n\nEncapsulates trip-specific toggles like roundtrips and fixed endpoints, letting you experiment with tour planning without reinitializing libosrm state.\n\n\n\n\n\n","category":"type"},{"location":"api/table/#Table-API","page":"Table API","title":"Table API","text":"Compute distance/duration matrices between multiple waypoints.","category":"section"},{"location":"api/table/#Functions","page":"Table API","title":"Functions","text":"","category":"section"},{"location":"api/table/#Types","page":"Table API","title":"Types","text":"","category":"section"},{"location":"api/table/#OpenSourceRoutingMachine.Tables._table_response_destruct-Tuple{Ptr{Nothing}}","page":"Table API","title":"OpenSourceRoutingMachine.Tables._table_response_destruct","text":"TableResponse\n\nOwns the libosrmc table response pointer and releases it when the Julia object gets garbage collected.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.Tables.get_destination_count-Tuple{TableResponse}","page":"Table API","title":"OpenSourceRoutingMachine.Tables.get_destination_count","text":"get_destination_count(response) -> Int\n\nSame as source_count but for destinations, keeping sanity checks symmetric.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.Tables.get_distance_matrix-Tuple{TableResponse}","page":"Table API","title":"OpenSourceRoutingMachine.Tables.get_distance_matrix","text":"get_distance_matrix(response) -> Matrix{Float64}\n\nIn-place variant for distances, mirroring duration_matrix to support allocation-free bulk work.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.Tables.get_duration_matrix-Tuple{TableResponse}","page":"Table API","title":"OpenSourceRoutingMachine.Tables.get_duration_matrix","text":"get_duration_matrix(response) -> Matrix{Float64}\n\nFill an existing Float64 buffer (vector or matrix, row-major) with durations so callers can avoid allocations when repeatedly querying OSRM.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.Tables.get_source_count-Tuple{TableResponse}","page":"Table API","title":"OpenSourceRoutingMachine.Tables.get_source_count","text":"get_source_count(response) -> Int\n\nHelps verify how many origins OSRM accepted before attempting to read matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.Tables.table-Tuple{OSRM, TableParams}","page":"Table API","title":"OpenSourceRoutingMachine.Tables.table","text":"table(osrm::OSRM, params::TableParams) -> TableResponse\n\nCalls libosrmc's Table endpoint directly, keeping the full response in-memory instead of going through osrm-routed.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.add_coordinate!-Tuple{TableParams, @NamedTuple{lat::Float64, lon::Float64}}","page":"Table API","title":"OpenSourceRoutingMachine.add_coordinate!","text":"add_coordinate!(params::TableParams, coord::LatLon)\n\nAppend a coordinate in (lat, lon) order to the current Table request.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.add_coordinate_with!-Tuple{TableParams, @NamedTuple{lat::Float64, lon::Float64}, Real, Integer, Integer}","page":"Table API","title":"OpenSourceRoutingMachine.add_coordinate_with!","text":"add_coordinate_with!(params::TableParams, coord::LatLon, radius, bearing, range)\n\nAppend a coordinate with radius and bearing hints so OSRM can snap more accurately when building distance/duration matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.add_destination!-Tuple{TableParams, Integer}","page":"Table API","title":"OpenSourceRoutingMachine.add_destination!","text":"add_destination!(params::TableParams, index)\n\nSame as add_source! but for destinations, enabling asymmetric matrices when needed.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.add_exclude!-Tuple{TableParams, AbstractString}","page":"Table API","title":"OpenSourceRoutingMachine.add_exclude!","text":"add_exclude!(params::TableParams, profile)\n\nExclude traffic classes (for example \"toll\" or \"ferry\") from matrix computations.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.add_source!-Tuple{TableParams, Integer}","page":"Table API","title":"OpenSourceRoutingMachine.add_source!","text":"add_source!(params::TableParams, index)\n\nSelects which coordinate acts as a source so you can build sparse matrices without reallocating params for each subset.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.as_json-Tuple{TableResponse}","page":"Table API","title":"OpenSourceRoutingMachine.as_json","text":"as_json(response::TableResponse) -> String\n\nRetrieve the entire response as JSON string.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.get_distance-Tuple{TableResponse, Integer, Integer}","page":"Table API","title":"OpenSourceRoutingMachine.get_distance","text":"get_distance(response, from, to) -> Float64\n\nExpose the meters-between calculation OSRM already computed for the matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.get_duration-Tuple{TableResponse, Integer, Integer}","page":"Table API","title":"OpenSourceRoutingMachine.get_duration","text":"get_duration(response, from, to) -> Float64\n\nReturn OSRM's travel time between two matrix indices so we stay consistent with the engine (returns Inf when no route exists).\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_annotations_mask!-Tuple{TableParams, AbstractString}","page":"Table API","title":"OpenSourceRoutingMachine.set_annotations_mask!","text":"set_annotations_mask!(params::TableParams, mask)\n\nRestricts OSRM's matrix annotations (duration, distance, etc.) so data exports only include the metrics you plan to consume.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_approach!-Tuple{TableParams, Integer, Any}","page":"Table API","title":"OpenSourceRoutingMachine.set_approach!","text":"set_approach!(params::TableParams, coordinate_index, approach)\n\nControl which side of the road a vehicle should approach for a particular matrix coordinate.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_bearing!-Tuple{TableParams, Integer, Integer, Integer}","page":"Table API","title":"OpenSourceRoutingMachine.set_bearing!","text":"set_bearing!(params::TableParams, coordinate_index, value, range)\n\nConstrain snapping using a heading and allowed deviation so origins/destinations prefer edges aligned with the current travel direction.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_fallback_coordinate_type!-Tuple{TableParams, Union{Nothing, AbstractString}}","page":"Table API","title":"OpenSourceRoutingMachine.set_fallback_coordinate_type!","text":"set_fallback_coordinate_type!(params::TableParams, coord_type)\n\nControls whether fallback results snap to input coordinates or to network snaps, ensuring downstream code interprets placeholders correctly.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_fallback_speed!-Tuple{TableParams, Real}","page":"Table API","title":"OpenSourceRoutingMachine.set_fallback_speed!","text":"set_fallback_speed!(params::TableParams, speed)\n\nDefines the heuristic speed OSRM should use when a cell is unreachable, letting you distinguish true disconnections from missing data.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_generate_hints!-Tuple{TableParams, Bool}","page":"Table API","title":"OpenSourceRoutingMachine.set_generate_hints!","text":"set_generate_hints!(params::TableParams, on)\n\nToggle generation of reusable hints for all snapped coordinates in the table.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_hint!-Tuple{TableParams, Integer, AbstractString}","page":"Table API","title":"OpenSourceRoutingMachine.set_hint!","text":"set_hint!(params::TableParams, coordinate_index, hint)\n\nAttach a precomputed hint to a matrix coordinate to speed up repeated queries over the same snapped locations.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_radius!-Tuple{TableParams, Integer, Real}","page":"Table API","title":"OpenSourceRoutingMachine.set_radius!","text":"set_radius!(params::TableParams, coordinate_index, radius)\n\nOverride the default snapping radius for a specific coordinate in the matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_scale_factor!-Tuple{TableParams, Real}","page":"Table API","title":"OpenSourceRoutingMachine.set_scale_factor!","text":"set_scale_factor!(params::TableParams, factor)\n\nScales unreachable entries so visualization layers can downplay them rather than treating them as raw infinity.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_skip_waypoints!-Tuple{TableParams, Bool}","page":"Table API","title":"OpenSourceRoutingMachine.set_skip_waypoints!","text":"set_skip_waypoints!(params::TableParams, on)\n\nAsk OSRM to omit waypoints from the Table response to reduce payload size.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.set_snapping!-Tuple{TableParams, Any}","page":"Table API","title":"OpenSourceRoutingMachine.set_snapping!","text":"set_snapping!(params::TableParams, snapping)\n\nConfigure how aggressively OSRM should snap matrix coordinates to the road network using the Snapping enum.\n\n\n\n\n\n","category":"method"},{"location":"api/table/#OpenSourceRoutingMachine.Tables.TableParams","page":"Table API","title":"OpenSourceRoutingMachine.Tables.TableParams","text":"TableParams()\n\nWraps libosrmc's table parameter object, keeping the GC responsible for cleanup while you build many-to-many queries in Julia.\n\n\n\n\n\n","category":"type"},{"location":"api/match/#Match-API","page":"Match API","title":"Match API","text":"Map GPS traces to road networks.","category":"section"},{"location":"api/match/#Functions","page":"Match API","title":"Functions","text":"","category":"section"},{"location":"api/match/#Types","page":"Match API","title":"Types","text":"","category":"section"},{"location":"api/match/#Base.match-Tuple{OSRM, MatchParams}","page":"Match API","title":"Base.match","text":"match(osrm::OSRM, params::MatchParams) -> MatchResponse\n\nExtends Base.match so callers can invoke OSRM's native matcher directly and receive a typed response without HTTP hops.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches._match_response_destruct-Tuple{Ptr{Nothing}}","page":"Match API","title":"OpenSourceRoutingMachine.Matches._match_response_destruct","text":"MatchResponse\n\nOwns the raw libosrmc match response pointer and ensures it is freed exactly once when the Julia object gets GC'd.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.add_alternatives!-Tuple{MatchParams, Bool}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.add_alternatives!","text":"add_alternatives!(params::MatchParams, on)\n\nAllows the matcher to keep alternate routes which helps downstream quality checks decide when to fall back.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.add_steps!-Tuple{MatchParams, Bool}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.add_steps!","text":"add_steps!(params::MatchParams, on)\n\nMirrors the Route behavior so callers can request per-step guidance while running map-matching.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.add_waypoint!-Tuple{MatchParams, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.add_waypoint!","text":"add_waypoint!(params::MatchParams, index)\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.as_json-Tuple{MatchResponse}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.as_json","text":"as_json(response::MatchResponse) -> String\n\nRetrieve OSRM's canonical JSON payload for logging or compatibility with existing tooling.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.clear_waypoints!-Tuple{MatchParams}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.clear_waypoints!","text":"clear_waypoints!(params::MatchParams)\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.get_route_confidence-Tuple{MatchResponse, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.get_route_confidence","text":"get_route_confidence(response::MatchResponse, route_index) -> Float64\n\nSurface OSRM's built-in confidence metric so applications can fall back when a match looks unreliable.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.get_route_count-Tuple{MatchResponse}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.get_route_count","text":"get_route_count(response::MatchResponse) -> Int\n\nExpose the number of alternative routes without JSON parsing so callers can preallocate downstream data structures.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.get_route_distance-Tuple{MatchResponse, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.get_route_distance","text":"get_route_distance(response::MatchResponse, route_index) -> Float64\n\nLet OSRM be the source of truth for cumulative distance instead of re-integrating coordinates client-side.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.get_route_duration-Tuple{MatchResponse, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.get_route_duration","text":"get_route_duration(response::MatchResponse, route_index) -> Float64\n\nReuses OSRM's travel time heuristics so Julia callers stay aligned with server estimates.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.get_tracepoint_coordinate-Tuple{MatchResponse, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.get_tracepoint_coordinate","text":"get_tracepoint_coordinate(response::MatchResponse, index) -> LatLon\n\nReturn the latitude and longitude of the index-th tracepoint in the response.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.get_tracepoint_count-Tuple{MatchResponse}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.get_tracepoint_count","text":"get_tracepoint_count(response::MatchResponse) -> Int\n\nReveal how many tracepoints OSRM accepted, which helps detect truncated GPS streams early.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.get_tracepoint_is_null-Tuple{MatchResponse, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.get_tracepoint_is_null","text":"get_tracepoint_is_null(response::MatchResponse, index) -> Bool\n\nFlags unmatched points so callers can remove or interpolate them before further processing.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.set_annotations!-Tuple{MatchParams, AbstractString}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.set_annotations!","text":"set_annotations!(params::MatchParams, annotations)\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.set_continue_straight!-Tuple{MatchParams, Bool}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.set_continue_straight!","text":"set_continue_straight!(params::MatchParams, on)\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.set_geometries!-Tuple{MatchParams, AbstractString}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.set_geometries!","text":"set_geometries!(params::MatchParams, geometries)\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.set_number_of_alternatives!-Tuple{MatchParams, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.set_number_of_alternatives!","text":"set_number_of_alternatives!(params::MatchParams, count)\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.set_overview!-Tuple{MatchParams, AbstractString}","page":"Match API","title":"OpenSourceRoutingMachine.Matches.set_overview!","text":"set_overview!(params::MatchParams, overview)\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.add_timestamp!-Tuple{MatchParams, Integer}","page":"Match API","title":"OpenSourceRoutingMachine.add_timestamp!","text":"add_timestamp!(params::MatchParams, timestamp)\n\nFeeds per-point timestamps so OSRM can respect vehicle speed between samples, which improves matching on sparse GPS data.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.set_gaps!-Tuple{MatchParams, AbstractString}","page":"Match API","title":"OpenSourceRoutingMachine.set_gaps!","text":"set_gaps!(params::MatchParams, gaps)\n\nTells OSRM how to treat missing samples (split vs. ignore), letting analytics pipelines encode their tolerance for GPS outages.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.set_tidy!-Tuple{MatchParams, Bool}","page":"Match API","title":"OpenSourceRoutingMachine.set_tidy!","text":"set_tidy!(params::MatchParams, on)\n\nRequests OSRM to drop redundant tracepoints, which reduces downstream storage when high-frequency logs are matched.\n\n\n\n\n\n","category":"method"},{"location":"api/match/#OpenSourceRoutingMachine.Matches.MatchParams","page":"Match API","title":"OpenSourceRoutingMachine.Matches.MatchParams","text":"MatchParams()\n\nHolds the map-matching options (timestamps, gap handling, etc.) so GPS trace processing can mutate a single object across requests.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Graph-example","page":"Examples","title":"Graph example","text":"Before using OSRM services, you need to build a graph from OpenStreetMap data:\n\nusing OpenSourceRoutingMachine\nusing OpenSourceRoutingMachine.Graphs\n\nosm_path = \"hamburg-latest.osm.pbf\" # or any other OSM file\nosrm_base_path = \"hamburg-latest.osrm\"   # corresponding OSRM base path for all graph files\n\n# Build MLD graph (recommended for most use cases)\nextract(osm_path; profile = Profile.car)\npartition(osrm_base_path)\ncustomize(osrm_base_path)\n\n# Or build CH graph\nextract(osm_path; profile = Profile.car)\ncontract(osrm_base_path)","category":"section"},{"location":"examples/#Nearest-example","page":"Examples","title":"Nearest example","text":"Nearest finds the nearest road segment to a point.\n\nusing OpenSourceRoutingMachine\nusing OpenSourceRoutingMachine.Nearests\n\nosrm_base_path = \"hamburg-latest.osrm\"\nosrm = OSRM(osrm_base_path)\n\nparams = NearestParams()\nadd_coordinate!(params, LatLon(53.5511, 9.9937))\nset_number_of_results!(params, 5)  # Get 5 nearest points\n\nresponse = nearest(osrm, params)\ncnt = get_count(response)  # Number of results\n\n# Access first result\ncoord = get_coordinate(response, 1)\nname = get_name(response, 1)\ndist = get_distance(response, 1)\nhint = get_hint(response, 1)","category":"section"},{"location":"examples/#Route-example","page":"Examples","title":"Route example","text":"Route calculates the shortest path between two or more waypoints.\n\nusing OpenSourceRoutingMachine\nusing OpenSourceRoutingMachine.Routes\n\nosrm_base_path = \"hamburg-latest.osrm\"\nosrm = OSRM(osrm_base_path)\n\n# Create route parameters\nparams = RouteParams()\nadd_coordinate!(params, LatLon(53.5511, 9.9937))  # Start: Hamburg city center\nadd_coordinate!(params, LatLon(53.6304, 9.9882))  # End: Hamburg airport\n\n# Calculate route\nresponse = route(osrm, params)\n\n# Get results\ndist = get_distance(response)      # Distance in meters\ndur = get_duration(response)       # Duration in seconds","category":"section"},{"location":"examples/#Match-example","page":"Examples","title":"Match example","text":"Match maps GPS traces to road networks.\n\nusing OpenSourceRoutingMachine\nusing OpenSourceRoutingMachine.Matches\n\nosrm_base_path = \"hamburg-latest.osrm\"\nosrm = OSRM(osrm_base_path)\n\nparams = MatchParams()\nadd_coordinate!(params, LatLon(53.5511, 9.9937))\nadd_coordinate!(params, LatLon(53.5512, 9.9940))\nadd_coordinate!(params, LatLon(53.5513, 9.9945))\n\nresponse = match(osrm, params)\n\n# Get results\ndist = get_distance(response)      # Distance in meters\ndur = get_duration(response)       # Duration in seconds","category":"section"},{"location":"examples/#Table-example","page":"Examples","title":"Table example","text":"Table computes distance/duration matrices between multiple waypoints.\n\nusing OpenSourceRoutingMachine\nusing OpenSourceRoutingMachine.Tables\n\nosrm_base_path = \"hamburg-latest.osrm\"\nosrm = OSRM(osrm_base_path)\n\nparams = TableParams()\n# Add coordinates first\nadd_coordinate!(params, LatLon(53.5511, 9.9937))  # Index 0\nadd_coordinate!(params, LatLon(53.6304, 9.9882))  # Index 1\nadd_coordinate!(params, LatLon(53.5417, 9.9667))  # Index 2\nadd_coordinate!(params, LatLon(53.5528, 9.9352))  # Index 3\n\n# Mark which coordinates are sources and destinations\nadd_source!(params, 1)\nadd_source!(params, 2)\nadd_destination!(params, 3)\nadd_destination!(params, 4)\n\nresponse = table(osrm, params)\n\n# Access distance/duration between sources and destinations\ndurations = get_duration_matrix(response)\ndistances = get_distance_matrix(response)","category":"section"},{"location":"api/graphs/#Graphs-API","page":"Graphs API","title":"Graphs API","text":"Build and customize OSRM graphs (MLD and CH algorithms).","category":"section"},{"location":"api/graphs/#OpenSourceRoutingMachine.Graphs.contract-Tuple{AbstractString}","page":"Graphs API","title":"OpenSourceRoutingMachine.Graphs.contract","text":"contract(osrm_base_path; extra_args=String[])\ncontract(osrm_base_path; extra_args=String[])\n\nWraps osrm-contract so CH pipelines can be triggered from Julia without invoking shell scripts manually.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#OpenSourceRoutingMachine.Graphs.customize-Tuple{AbstractString}","page":"Graphs API","title":"OpenSourceRoutingMachine.Graphs.customize","text":"customize(osrm_base_path; extra_args=String[])\n\nCalls osrm-customize to finish MLD setup, keeping the artifact-provided binary and flags centralized.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#OpenSourceRoutingMachine.Graphs.extract-Tuple{AbstractString}","page":"Graphs API","title":"OpenSourceRoutingMachine.Graphs.extract","text":"extract(osm_path; profile=Profile.car, extra_args=String[])\n\nRuns the bundled osrm-extract with the correct Lua profile, ensuring graph builds behave the same on every machine.\n\nOSRM 6.0 automatically creates output files based on the input file name in the same directory as the input file.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#OpenSourceRoutingMachine.Graphs.partition-Tuple{AbstractString}","page":"Graphs API","title":"OpenSourceRoutingMachine.Graphs.partition","text":"partition(osrm_base_path; extra_args=String[])\n\nExecutes osrm-partition on an existing .osrm file so MLD preparations stay in Julia scripts rather than shell pipelines.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#OpenSourceRoutingMachine.Graphs.profile_lua_path-Tuple{OpenSourceRoutingMachine.Graphs.Profile.T}","page":"Graphs API","title":"OpenSourceRoutingMachine.Graphs.profile_lua_path","text":"profile_lua_path(profile::ProfileType) -> String\n\nReturn the absolute path to the Lua profile corresponding to the provided Profile value, even when the artifact relocates files, so callers never hard code resource paths.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#OpenSourceRoutingMachine.Graphs.OSRMCommandError","page":"Graphs API","title":"OpenSourceRoutingMachine.Graphs.OSRMCommandError","text":"OSRMCommandError(cmd, exitcode)\n\nCarries the failing command and exit code so build scripts can surface the exact OSRM CLI error without scraping STDOUT.\n\n\n\n\n\n","category":"type"},{"location":"api/route/#Route-API","page":"Route API","title":"Route API","text":"Calculate routes between multiple waypoints.","category":"section"},{"location":"api/route/#Functions","page":"Route API","title":"Functions","text":"","category":"section"},{"location":"api/route/#Types","page":"Route API","title":"Types","text":"","category":"section"},{"location":"api/route/#OpenSourceRoutingMachine.Routes._route_response_destruct-Tuple{Ptr{Nothing}}","page":"Route API","title":"OpenSourceRoutingMachine.Routes._route_response_destruct","text":"RouteResponse\n\nOwns the libosrmc route response pointer and cleans it up automatically when the Julia object is collected.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_alternative_count-Tuple{RouteResponse}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_alternative_count","text":"get_alternative_count(response) -> Int\n\nExpose how many alternate routes OSRM generated so UI layers can decide whether to show a picker.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_distance_at-Tuple{RouteResponse, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_distance_at","text":"get_distance_at(response, route_index) -> Float64\n\nFetch the distance for a specific alternative instead of assuming the primary route is always desired.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_duration_at-Tuple{RouteResponse, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_duration_at","text":"get_duration_at(response, route_index) -> Float64\n\nPer-alternative durations help heuristics compare ETA differences before downloading geometries.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_geometry_coordinate-Tuple{RouteResponse, Integer, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_geometry_coordinate","text":"geometry_coordinate(response::RouteResponse, route_index::Integer, coord_index::Integer) -> LatLon\n\nReturn the latitude and longitude of a specific coordinate in the decoded route geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_geometry_coordinate_count","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_geometry_coordinate_count","text":"get_geometry_coordinate_count(response::RouteResponse, route_index=1) -> Int\n\nReturn how many decoded coordinates are present in the route geometry for the given alternative index.\n\n\n\n\n\n","category":"function"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_geometry_polyline","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_geometry_polyline","text":"get_geometry_polyline(response, route_index=1) -> String\n\nReturn the encoded polyline OSRM generated so clients can render it without reconstructing geometries.\n\n\n\n\n\n","category":"function"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_leg_count","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_leg_count","text":"get_leg_count(response::RouteResponse, route_index=1) -> Int\n\nReturn how many legs (segments between waypoints) the selected alternative has.\n\n\n\n\n\n","category":"function"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_step_count-Tuple{RouteResponse, Integer, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_step_count","text":"get_step_count(response::RouteResponse, route_index, leg_index) -> Int\n\nNumber of maneuver steps within a given leg of the selected alternative.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_step_distance-Tuple{RouteResponse, Integer, Integer, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_step_distance","text":"get_step_distance(response::RouteResponse, route_index, leg_index, step_index) -> Float64\n\nDistance in meters for a particular maneuver step.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_step_duration-Tuple{RouteResponse, Integer, Integer, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_step_duration","text":"get_step_duration(response::RouteResponse, route_index, leg_index, step_index) -> Float64\n\nTravel time in seconds for a particular maneuver step.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_step_instruction-Tuple{RouteResponse, Integer, Integer, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_step_instruction","text":"get_step_instruction(response::RouteResponse, route_index, leg_index, step_index) -> String\n\nHuman-readable instruction string for a particular maneuver step.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.get_waypoint_name-Tuple{RouteResponse, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.get_waypoint_name","text":"get_waypoint_name(response::RouteResponse, index) -> String\n\nName string associated with the index-th waypoint when available.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.route-Tuple{OSRM, RouteParams}","page":"Route API","title":"OpenSourceRoutingMachine.Routes.route","text":"route(osrm::OSRM, params::RouteParams) -> RouteResponse\n\nCalls the libosrmc Route endpoint directly, avoiding HTTP and keeping responses in-memory.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.add_alternatives!-Tuple{RouteParams, Bool}","page":"Route API","title":"OpenSourceRoutingMachine.add_alternatives!","text":"add_alternatives!(params::RouteParams, on)\n\nSignals that clients plan to evaluate multiple candidate routes, so OSRM keeps producing alternates instead of pruning early.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.add_coordinate!-Tuple{RouteParams, @NamedTuple{lat::Float64, lon::Float64}}","page":"Route API","title":"OpenSourceRoutingMachine.add_coordinate!","text":"add_coordinate!(params::RouteParams, coord::LatLon)\n\nAppend a coordinate to the current request in (lat, lon) order, reusing the same RouteParams across multiple calls.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.add_coordinate_with!-Tuple{RouteParams, @NamedTuple{lat::Float64, lon::Float64}, Real, Integer, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.add_coordinate_with!","text":"add_coordinate_with!(params::RouteParams, coord::LatLon, radius, bearing, range)\n\nAppend a coordinate together with search radius and bearing hints so OSRM can snap more accurately to the road network.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.add_exclude!-Tuple{RouteParams, AbstractString}","page":"Route API","title":"OpenSourceRoutingMachine.add_exclude!","text":"add_exclude!(params::RouteParams, profile)\n\nExclude traffic classes (e.g. \"toll\", \"ferry\") from consideration when computing routes.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.add_steps!-Tuple{RouteParams, Bool}","page":"Route API","title":"OpenSourceRoutingMachine.add_steps!","text":"add_steps!(params::RouteParams, on)\n\nRequests OSRM to emit per-step instructions, which is necessary when building turn-by-turn guidance layers.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.add_waypoint!-Tuple{RouteParams, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.add_waypoint!","text":"add_waypoint!(params::RouteParams, index)\n\nMarks the current coordinate as a waypoint so OSRM reports where routes diverge or visit intermediate stops.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.as_json-Tuple{RouteResponse}","page":"Route API","title":"OpenSourceRoutingMachine.as_json","text":"as_json(response::RouteResponse) -> String\n\nProvide the entire response as JSON string.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.clear_waypoints!-Tuple{RouteParams}","page":"Route API","title":"OpenSourceRoutingMachine.clear_waypoints!","text":"clear_waypoints!(params::RouteParams)\n\nResets waypoint selections in-place, letting you reuse the same parameter block for multiple experiments without reconstructing coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.get_distance-Tuple{RouteResponse}","page":"Route API","title":"OpenSourceRoutingMachine.get_distance","text":"get_distance(response::RouteResponse) -> Float64\n\nReturn OSRM's distance computation so callers do not have to integrate the polyline themselves.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.get_duration-Tuple{RouteResponse}","page":"Route API","title":"OpenSourceRoutingMachine.get_duration","text":"get_duration(response::RouteResponse) -> Float64\n\nRead OSRM's travel time estimate directly, keeping the Julia client aligned with server heuristics.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.get_waypoint_coordinate-Tuple{RouteResponse, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.get_waypoint_coordinate","text":"get_waypoint_coordinate(response::RouteResponse, index) -> LatLon\n\nReturn the latitude and longitude of the index-th waypoint in the response.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.get_waypoint_count-Tuple{RouteResponse}","page":"Route API","title":"OpenSourceRoutingMachine.get_waypoint_count","text":"get_waypoint_count(response::RouteResponse) -> Int\n\nReturn how many waypoints OSRM reported (start, end, and any intermediates).\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_annotations!-Tuple{RouteParams, AbstractString}","page":"Route API","title":"OpenSourceRoutingMachine.set_annotations!","text":"set_annotations!(params::RouteParams, annotations)\n\nAsks OSRM to emit per-edge metadata (speed, duration, etc.) so analytics jobs can inspect costs at a finer granularity.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_approach!-Tuple{RouteParams, Integer, Any}","page":"Route API","title":"OpenSourceRoutingMachine.set_approach!","text":"set_approach!(params::RouteParams, coordinate_index, approach)\n\nControl whether vehicles should approach waypoints from the curb, be unrestricted, or use the opposite side where supported.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_bearing!-Tuple{RouteParams, Integer, Integer, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.set_bearing!","text":"set_bearing!(params::RouteParams, coordinate_index, value, range)\n\nConstrain snapping using a heading and allowed deviation range so OSRM prefers edges aligned with the current travel direction.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_continue_straight!-Tuple{RouteParams, Bool}","page":"Route API","title":"OpenSourceRoutingMachine.set_continue_straight!","text":"set_continue_straight!(params::RouteParams, on)\n\nPrevents OSRM from suggesting hairpins at roundabouts when the application requires staying aligned with the current heading.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_generate_hints!-Tuple{RouteParams, Bool}","page":"Route API","title":"OpenSourceRoutingMachine.set_generate_hints!","text":"set_generate_hints!(params::RouteParams, on)\n\nAsk OSRM to emit reusable hints for snapped coordinates, which can be cached by clients to speed up future queries.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_geometries!-Tuple{RouteParams, AbstractString}","page":"Route API","title":"OpenSourceRoutingMachine.set_geometries!","text":"set_geometries!(params::RouteParams, geometries)\n\nChoose between polyline encodings to match downstream consumers (e.g. GeoJSON vs. polyline6) without rebuilding the request object.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_hint!-Tuple{RouteParams, Integer, AbstractString}","page":"Route API","title":"OpenSourceRoutingMachine.set_hint!","text":"set_hint!(params::RouteParams, coordinate_index, hint)\n\nAttach a precomputed hint to a coordinate to speed up subsequent queries that reuse the same snapped location.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_number_of_alternatives!-Tuple{RouteParams, Integer}","page":"Route API","title":"OpenSourceRoutingMachine.set_number_of_alternatives!","text":"set_number_of_alternatives!(params::RouteParams, count)\n\nCaps how many alternates OSRM should compute so you can bound latency for interactive use cases.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_overview!-Tuple{RouteParams, AbstractString}","page":"Route API","title":"OpenSourceRoutingMachine.set_overview!","text":"set_overview!(params::RouteParams, overview)\n\nControls how much geometry OSRM should include (full, simplified, or none), which directly impacts payload size.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_radius!-Tuple{RouteParams, Integer, Real}","page":"Route API","title":"OpenSourceRoutingMachine.set_radius!","text":"set_radius!(params::RouteParams, coordinate_index, radius)\n\nSet a per-coordinate search radius in meters, relaxing or tightening how far OSRM may move the point to find a routable edge.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_skip_waypoints!-Tuple{RouteParams, Bool}","page":"Route API","title":"OpenSourceRoutingMachine.set_skip_waypoints!","text":"set_skip_waypoints!(params::RouteParams, on)\n\nToggle whether OSRM should omit waypoint objects from the response to reduce payload size when only geometry and metrics are needed.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.set_snapping!-Tuple{RouteParams, Any}","page":"Route API","title":"OpenSourceRoutingMachine.set_snapping!","text":"set_snapping!(params::RouteParams, snapping)\n\nControl how aggressively OSRM should snap coordinates to the road network, using the Snapping enum for type safety.\n\n\n\n\n\n","category":"method"},{"location":"api/route/#OpenSourceRoutingMachine.Routes.RouteParams","page":"Route API","title":"OpenSourceRoutingMachine.Routes.RouteParams","text":"RouteParams()\n\nOwns the native route parameter handle so callers can build requests without allocating temporary structs for every query.\n\n\n\n\n\n","category":"type"},{"location":"api/tile/#Tile-API","page":"Tile API","title":"Tile API","text":"Generate vector tiles for visualization.","category":"section"},{"location":"api/tile/#Functions","page":"Tile API","title":"Functions","text":"","category":"section"},{"location":"api/tile/#Types","page":"Tile API","title":"Types","text":"","category":"section"},{"location":"api/tile/#OpenSourceRoutingMachine.Tiles.get_data-Tuple{TileResponse}","page":"Tile API","title":"OpenSourceRoutingMachine.Tiles.get_data","text":"get_data(response::TileResponse) -> Vector{UInt8}\n\nCopy the binary vector-tile payload into a Julia-owned buffer.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.Tiles.get_size-Tuple{TileResponse}","page":"Tile API","title":"OpenSourceRoutingMachine.Tiles.get_size","text":"get_size(response::TileResponse) -> Int\n\nGet the raw byte size of the vector tile payload.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.Tiles.tile-Tuple{OSRM, TileParams}","page":"Tile API","title":"OpenSourceRoutingMachine.Tiles.tile","text":"tile(osrm::OSRM, params::TileParams) -> TileResponse\n\nQuery the Tile service and return a response object.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.add_coordinate!-Tuple{TileParams, @NamedTuple{lat::Float64, lon::Float64}}","page":"Tile API","title":"OpenSourceRoutingMachine.add_coordinate!","text":"add_coordinate!(params::TileParams, coord::LatLon)\n\nAttach a single coordinate (usually the tile center) to the Tile request.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.add_coordinate_with!-Tuple{TileParams, @NamedTuple{lat::Float64, lon::Float64}, Real, Integer, Integer}","page":"Tile API","title":"OpenSourceRoutingMachine.add_coordinate_with!","text":"add_coordinate_with!(params::TileParams, coord::LatLon, radius, bearing, range)\n\nAttach a coordinate together with snapping hints so OSRM can refine which tile segment to return.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.add_exclude!-Tuple{TileParams, AbstractString}","page":"Tile API","title":"OpenSourceRoutingMachine.add_exclude!","text":"add_exclude!(params::TileParams, profile)\n\nExclude traffic classes when generating tiles, mirroring other services.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_approach!-Tuple{TileParams, Integer, Any}","page":"Tile API","title":"OpenSourceRoutingMachine.set_approach!","text":"set_approach!(params::TileParams, coordinate_index, approach)\n\nControl which side of the road a tile coordinate should approach from.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_bearing!-Tuple{TileParams, Integer, Integer, Integer}","page":"Tile API","title":"OpenSourceRoutingMachine.set_bearing!","text":"set_bearing!(params::TileParams, coordinate_index, value, range)\n\nConstrain tile snapping by heading so vector tiles line up with the travel direction.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_generate_hints!-Tuple{TileParams, Bool}","page":"Tile API","title":"OpenSourceRoutingMachine.set_generate_hints!","text":"set_generate_hints!(params::TileParams, on)\n\nToggle generation of reusable hints for tile coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_hint!-Tuple{TileParams, Integer, AbstractString}","page":"Tile API","title":"OpenSourceRoutingMachine.set_hint!","text":"set_hint!(params::TileParams, coordinate_index, hint)\n\nProvide a precomputed hint for a coordinate to avoid full snapping work when fetching tiles repeatedly.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_radius!-Tuple{TileParams, Integer, Real}","page":"Tile API","title":"OpenSourceRoutingMachine.set_radius!","text":"set_radius!(params::TileParams, coordinate_index, radius)\n\nOverride the default snapping radius for a specific tile coordinate.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_skip_waypoints!-Tuple{TileParams, Bool}","page":"Tile API","title":"OpenSourceRoutingMachine.set_skip_waypoints!","text":"set_skip_waypoints!(params::TileParams, on)\n\nAsk OSRM to omit waypoints from the Tile response metadata to keep payloads minimal.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_snapping!-Tuple{TileParams, Any}","page":"Tile API","title":"OpenSourceRoutingMachine.set_snapping!","text":"set_snapping!(params::TileParams, snapping)\n\nConfigure snapping strategy for tile coordinates using the Snapping enum.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_x!-Tuple{TileParams, Integer}","page":"Tile API","title":"OpenSourceRoutingMachine.set_x!","text":"set_x!(params::TileParams, x)\n\nUpdates the tile's X index in-place so map renderers can reuse the same request object while panning horizontally.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_y!-Tuple{TileParams, Integer}","page":"Tile API","title":"OpenSourceRoutingMachine.set_y!","text":"set_y!(params::TileParams, y)\n\nCompanion to set_x!; keeps vertical tile changes allocation-free.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.set_z!-Tuple{TileParams, Integer}","page":"Tile API","title":"OpenSourceRoutingMachine.set_z!","text":"set_z!(params::TileParams, z)\n\nAdjusts the zoom level without rebuilding the tile request, which keeps map overlays snappy when zooming.\n\n\n\n\n\n","category":"method"},{"location":"api/tile/#OpenSourceRoutingMachine.Tiles.TileParams","page":"Tile API","title":"OpenSourceRoutingMachine.Tiles.TileParams","text":"TileParams()\n\nKeeps an OSRM tile request mutable so map viewers can update XYZ coordinates in place when users pan the map.\n\n\n\n\n\n","category":"type"},{"location":"api/tile/#OpenSourceRoutingMachine.Tiles.TileResponse","page":"Tile API","title":"OpenSourceRoutingMachine.Tiles.TileResponse","text":"TileResponse\n\nOwns the libosrmc tile response pointer and ensures it gets freed when the Julia object is garbage collected.\n\n\n\n\n\n","category":"type"},{"location":"api/nearest/#Nearest-API","page":"Nearest API","title":"Nearest API","text":"Find the nearest road segment to a point.","category":"section"},{"location":"api/nearest/#Functions","page":"Nearest API","title":"Functions","text":"","category":"section"},{"location":"api/nearest/#Types","page":"Nearest API","title":"Types","text":"","category":"section"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests._nearest_response_destruct-Tuple{Ptr{Nothing}}","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests._nearest_response_destruct","text":"NearestResponse\n\nOwns the libosrmc nearest response pointer and frees it automatically when the object is garbage collected.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests.as_json-Tuple{NearestResponse}","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests.as_json","text":"as_json(response::NearestResponse) -> String\n\nReturns the entire response as JSON string.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests.get_coordinate-Tuple{NearestResponse, Integer}","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests.get_coordinate","text":"get_coordinate(response::NearestResponse, index) -> LatLon\n\nReturn the latitude and longitude of the index-th nearest point in the response.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests.get_count-Tuple{NearestResponse}","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests.get_count","text":"get_count(response::NearestResponse) -> Int\n\nExtends Base.count so callers can ask how many nearest hits OSRM returned without parsing JSON payloads.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests.get_hint-Tuple{NearestResponse, Integer}","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests.get_hint","text":"get_hint(response::NearestResponse, index) -> String\n\nReturns the base64-encoded hint produced by OSRM so callers can reuse it for follow-up queries.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests.get_name-Tuple{NearestResponse, Integer}","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests.get_name","text":"get_name(response::NearestResponse, index) -> String\n\nPull the textual label directly from OSRM to keep UI strings consistent with the engine.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests.nearest-Tuple{OSRM, NearestParams}","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests.nearest","text":"nearest(osrm::OSRM, params::NearestParams) -> NearestResponse\n\nCalls the libosrmc Nearest endpoint directly, avoiding HTTP round-trips.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.add_coordinate!-Tuple{NearestParams, @NamedTuple{lat::Float64, lon::Float64}}","page":"Nearest API","title":"OpenSourceRoutingMachine.add_coordinate!","text":"add_coordinate!(params::NearestParams, coord::LatLon)\n\nAppend a query coordinate for the Nearest search in (lat, lon) order.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.add_coordinate_with!-Tuple{NearestParams, @NamedTuple{lat::Float64, lon::Float64}, Real, Integer, Integer}","page":"Nearest API","title":"OpenSourceRoutingMachine.add_coordinate_with!","text":"add_coordinate_with!(params::NearestParams, coord::LatLon, radius, bearing, range)\n\nAppend a coordinate together with radius and bearing hints to influence how OSRM snaps to the road network when finding nearest points.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.add_exclude!-Tuple{NearestParams, AbstractString}","page":"Nearest API","title":"OpenSourceRoutingMachine.add_exclude!","text":"add_exclude!(params::NearestParams, profile)\n\nExclude traffic classes (e.g. \"toll\", \"ferry\") when searching for nearest edges.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.get_distance-Tuple{NearestResponse, Integer}","page":"Nearest API","title":"OpenSourceRoutingMachine.get_distance","text":"get_distance(response::NearestResponse, index) -> Float64\n\nReuse OSRM's precomputed meters-to-target instead of recomputing client-side.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_approach!-Tuple{NearestParams, Integer, Any}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_approach!","text":"set_approach!(params::NearestParams, coordinate_index, approach)\n\nControl which side of the road to approach when evaluating nearest candidates.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_bearing!-Tuple{NearestParams, Integer, Integer, Integer}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_bearing!","text":"set_bearing!(params::NearestParams, coordinate_index, value, range)\n\nConstrain Nearest snapping by heading, preferring candidates aligned with the current direction of travel.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_generate_hints!-Tuple{NearestParams, Bool}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_generate_hints!","text":"set_generate_hints!(params::NearestParams, on)\n\nToggle generation of hints for Nearest results so callers can reuse them for follow-up queries.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_hint!-Tuple{NearestParams, Integer, AbstractString}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_hint!","text":"set_hint!(params::NearestParams, coordinate_index, hint)\n\nAttach a precomputed hint for a candidate so repeated Nearest queries can skip full snapping work.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_number_of_results!-Tuple{NearestParams, Integer}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_number_of_results!","text":"set_number_of_results!(params::NearestParams, n)\n\nCaps how many candidates OSRM should return, keeping proximity lookups bounded for UIs that only display the top-k matches.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_radius!-Tuple{NearestParams, Integer, Real}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_radius!","text":"set_radius!(params::NearestParams, coordinate_index, radius)\n\nSet a per-coordinate snapping radius in meters for Nearest lookups.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_skip_waypoints!-Tuple{NearestParams, Bool}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_skip_waypoints!","text":"set_skip_waypoints!(params::NearestParams, on)\n\nAsk OSRM to omit waypoint objects from the response to keep Nearest payloads minimal.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.set_snapping!-Tuple{NearestParams, Any}","page":"Nearest API","title":"OpenSourceRoutingMachine.set_snapping!","text":"set_snapping!(params::NearestParams, snapping)\n\nConfigure the snapping strategy for Nearest requests using the Snapping enum.\n\n\n\n\n\n","category":"method"},{"location":"api/nearest/#OpenSourceRoutingMachine.Nearests.NearestParams","page":"Nearest API","title":"OpenSourceRoutingMachine.Nearests.NearestParams","text":"NearestParams()\n\nProvides a reusable parameter block for Nearest requests so iterative proximity searches do not constantly rebuild C structs.\n\n\n\n\n\n","category":"type"},{"location":"#OpenSourceRoutingMachine.jl","page":"Home","title":"OpenSourceRoutingMachine.jl","text":"A Julia wrapper for OSRM (Open Source Routing Machine), providing high-performance routing, matching, and geospatial analysis capabilities directly in Julia. Being a thin wrapper around OSRM, it might not provide the most ergonomic API, which might be established in a separate package at one point.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Graph Building: Build and customize OSRM graphs (MLD and CH algorithms)\nNearest Service: Find the nearest road segment to a point\nRoute Service: Calculate routes between multiple waypoints\nMatch Service: Map GPS traces to road networks\nTable Service: Compute distance/duration matrices\nTrip Service: Solve traveling salesman problems\nTile Service: Generate vector tiles for visualization","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"OpenSourceRoutingMachine\", url=\"https://github.com/moviro-hub/OpenSourceRoutingMachine.jl\")\n\nSee the Examples section for end-to-end usage patterns.","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"Pages = [\n    \"api/core.md\",\n    \"api/graphs.md\",\n    \"api/nearest.md\",\n    \"api/route.md\",\n    \"api/match.md\",\n    \"api/table.md\",\n    \"api/trip.md\",\n    \"api/tile.md\",\n]","category":"section"}]
}
